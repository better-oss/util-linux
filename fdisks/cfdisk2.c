#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <signal.h>

#ifdef HAVE_SLANG_H
#include <slang.h>
#elif defined(HAVE_SLANG_SLANG_H)
#include <slang/slang.h>
#endif

#ifdef HAVE_SLCURSES_H
#include <slcurses.h>
#elif defined(HAVE_SLANG_SLCURSES_H)
#include <slang/slcurses.h>
#elif defined(HAVE_NCURSESW_NCURSES_H) && defined(HAVE_WIDECHAR)
#include <ncursesw/ncurses.h>
#elif defined(HAVE_NCURSES_H)
#include <ncurses.h>
#elif defined(HAVE_NCURSES_NCURSES_H)
#include <ncurses/ncurses.h>
#endif

#ifdef HAVE_WIDECHAR
#include <wctype.h>
#endif

#include "c.h"
#include "closestream.h"
#include "nls.h"
#include "strutils.h"

#include "fdiskP.h"

#define ARROW_CURSOR_STRING	">>> "
#define ARROW_CURSOR_DUMMY	"    "
#define ARROW_CURSOR_WIDTH	(sizeof(ARROW_CURSOR_STRING) - 1)



struct cfdisk {
	struct fdisk_context	*cxt;

	char	*tb_buf;	/* result from libfdisk list() operation */
	size_t	tb_sz;		/* size of the tb_buf */
	char	**tb_lines;	/* array with lines */
	size_t	tb_nlines;	/* number of lines */

	size_t	part_cur;	/* current partition <0..N> */
	size_t	nparts;		/* number of partitions */

	unsigned int	ui_enabled : 1;
};

/*
 * @tb contains unaligned raw data (with infor about partitions)
 * as generated by libfdisk. Now we have to convert individual chunks of
 * the data to one large string by tt_print_table() function.
 *
 * This function is triggered by fdisk_list_partitions() by libfdisk
 * ASK API callback.
 */
static int tab_update_buffer(struct cfdisk *cf, struct tt *tb)
{
	FILE *stream;
	char *p;
	size_t i;

	assert(cf);

	free(cf->tb_buf);
	free(cf->tb_lines);
	cf->tb_buf = NULL;
	cf->tb_sz = 0;
	cf->tb_nlines = 0;
	cf->nparts = 0;

	cf->nparts = cf->tb_nlines = tb_get_nlines(tb);
	if (!cf->tb_nlines)
		return 0;

	cf->tb_nlines++;	/* header */

	/* overwrite defaults defined by libfdisk */
	tt_set_flags(tb, tt_get_flags(tb) | TT_FL_MAX);
	tt_set_termreduce(tb, ARROW_CURSOR_WIDTH);

	/* create a streem for output */
	stream = open_memstream(&cf->tb_buf, &cf->tb_sz);
	if (!stream) {
		warn(_("failed to open memory stream"));
		return -ENOMEM;
	}

	tt_set_stream(tb, stream);
	tt_print_table(tb);
	fclose(stream);

	if (!cf->tb_buf)
		return -ENOMEM;

	/* allocate array of lines and split the buffer to the lines */
	cf->tb_lines = calloc(cf->tb_nlines, sizeof(char *));
	if (!cf->tb_lines)
		return -ENOMEM;

	for (p = cf->tb_buf, i = 0; p && i < cf->tb_nlines; i++) {
		cf->tb_lines[i] = p;
		p = strchr(p, '\n');
		if (p) {
			*p = '\0';
			p++;
		}
	}

	return 0;
}

static int ask_callback(struct fdisk_context *cxt, struct fdisk_ask *ask,
		    void *data __attribute__((__unused__)))
{
	struct cfdisk *cf = (struct cfdisk *) data;
	int rc = 0;

	assert(cxt);
	assert(ask);

	switch(fdisk_ask_get_type(ask)) {
	case FDISK_ASKTYPE_INFO:
		fputs(fdisk_ask_print_get_mesg(ask), stdout);
		fputc('\n', stdout);
		break;
	case FDISK_ASKTYPE_WARNX:
		fputs(fdisk_ask_print_get_mesg(ask), stderr);
		fputc('\n', stderr);
		break;
	case FDISK_ASKTYPE_WARN:
		fputs(fdisk_ask_print_get_mesg(ask), stderr);
		errno = fdisk_ask_print_get_errno(ask);
		fprintf(stderr, ": %m\n");
		break;
	case FDISK_ASKTYPE_TABLE:
		tab_update_buffer(cf, fdisk_ask_get_table(ask));
		break;
	default:
		warnx(_("internal error: unsupported dialog type %d"), fdisk_ask_get_type(ask));
		return -EINVAL;
	}
	return rc;
}


static int ui_end(struct cfdisk *cf)
{
	if (cf && !cf->ui_enabled)
		return -EINVAL;

#if defined(HAVE_SLCURSES_H) || defined(HAVE_SLANG_SLCURSES_H)
	SLsmg_gotorc(LINES - 1, 0);
	SLsmg_refresh();
#else
	mvcur(0, COLS - 1, LINES-1, 0);
#endif
	nl();
	endwin();
	printf("\n");
	return 0;
}

static void die_on_signal(int dummy __attribute__((__unused__)))
{
	ui_end(NULL);
	exit(EXIT_FAILURE);
}

static int ui_init(struct cfdisk *cf)
{
	struct sigaction sa;

	/* setup SIGCHLD handler */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sa.sa_handler = die_on_signal;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);

	cf->ui_enabled = 1;
	initscr();

	cbreak();
	noecho();
	nonl();
	curs_set(0);
	keypad(stdscr, TRUE);

	return 0;
}

static void ui_draw_partition(struct cfdisk *cf, size_t i)
{
	int ln = i + 1;			/* skip header */
	int cl = ARROW_CURSOR_WIDTH;	/* we need extra space for cursor */

	if (cf->part_cur == i) {
		standout();
		mvaddstr(ln, 0, ARROW_CURSOR_STRING);
		mvaddstr(ln, cl, cf->tb_lines[i + 1]);
		standend();
	} else {
		mvaddstr(ln, 0, ARROW_CURSOR_DUMMY);
		mvaddstr(ln, cl, cf->tb_lines[i + 1]);
	}

}

static int ui_draw_table(struct cfdisk *cf)
{
	size_t i;
	int cl = ARROW_CURSOR_WIDTH;

	if (cf->tb_nlines - 1 < cf->part_cur)
		cf->part_cur = cf->tb_nlines - 1;

	/* print header */
	mvaddstr(0, cl, cf->tb_lines[0]);

	/* print partitions */
	for (i = 0; i < cf->nparts; i++)
		ui_draw_partition(cf, i);

	return 0;
}

static int ui_table_goto(struct cfdisk *cf, int where)
{
	size_t old;

	if (where < 0)
		where = 0;
	else if ((size_t) where > cf->nparts - 1)
		where = cf->nparts - 1;

	if ((size_t) where == cf->part_cur)
		return 0;

	old = cf->part_cur;
	cf->part_cur = where;

	ui_draw_partition(cf, old);	/* cleanup old */
	ui_draw_partition(cf, where);	/* draw new */
	refresh();
	return 0;
}

static int ui_refresh(struct cfdisk *cf)
{
	erase();

	if (!cf->ui_enabled)
		return -EINVAL;

	ui_draw_table(cf);
	refresh();
	return 0;
}

static int ui_run(struct cfdisk *cf)
{
	int rc;

	rc = ui_refresh(cf);
	if (rc)
		return rc;
	do {
		int key = getch();

		if (key == 'q')
			break;

		switch (key) {
		case KEY_DOWN:
		case '\016':	/* ^N */
		case 'j':	/* Vi-like alternative */
			ui_table_goto(cf, cf->part_cur + 1);
			break;
		case KEY_UP:
		case '\020':	/* ^P */
		case 'k':	/* Vi-like alternative */
			ui_table_goto(cf, cf->part_cur - 1);
			break;
		case KEY_HOME:
			ui_table_goto(cf, 0);
			break;
		case KEY_END:
			ui_table_goto(cf, cf->nparts);
			break;
		default:
			beep();
		}
	} while (1);

	return 0;
}

int main(int argc, char *argv[])
{
	struct cfdisk _cf = { .part_cur = 0 },
		      *cf = &_cf;

	setlocale(LC_ALL, "");
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);
	atexit(close_stdout);

	fdisk_init_debug(0);
	cf->cxt = fdisk_new_context();
	if (!cf->cxt)
		err(EXIT_FAILURE, _("failed to allocate libfdisk context"));

	fdisk_context_set_ask(cf->cxt, ask_callback, (void *) cf);

	if (argc != 2)
		err(EXIT_FAILURE, "usage: %s <device>", argv[0]);

	if (fdisk_context_assign_device(cf->cxt, argv[optind], 0) != 0)
		err(EXIT_FAILURE, _("cannot open %s"), argv[optind]);

	if (fdisk_list_partitions(cf->cxt, NULL, 0))
		errx(EXIT_FAILURE, _("failed to read partitions"));

	/* Don't use err(), warn() from this point */
	ui_init(cf);
	ui_run(cf);
	ui_end(cf);

	fdisk_free_context(cf->cxt);
	return EXIT_SUCCESS;
}
